# Отчет по `src/store/index.js`

## Кратко о структуре
- Vuex store с большим набором ссылочных справочников, company-scoped данных и пользовательских настроек.
- Кэширование разбито на три слоя: localStorage (общие справочники), IndexedDB (крупные выборки), оперативное состояние в store. TTL управляется через `CACHE_TTL` и `STORE_CONFIG`.
- Используются контроллеры API (в т.ч. simple-режим) и утилиты `CacheInvalidator`, `retryWithExponentialBackoff`, `CompanyDto`, `ClientDto`, `ProjectDto`, `ProductSearchDto`.
- Синхронизация вкладок: `initializeStorageSync` слушает изменения userSettings/persisted state и триггерит смену компании без запросов к серверу.
- Персистенция настроек/кэшей через несколько инстансов `createPersistedState` с фильтрами, редьюсерами и assertStorage.

## Кэш и инвалидация
- Глобальные справочники (`units`, `currencies`, `users`, статусы и т.д.) кэшируются в localStorage, с TTL-проверками при парсинге и персисте.
- Company-scoped данные (`warehouses`, `cashRegisters`, `clients`, `projects`, категории и т.д.) кэшируются и сбрасываются при смене компании через `CacheInvalidator.invalidateAll` и `CLEAR_COMPANY_DATA`.
- Большие данные (`allProductsData`, `clientsData`, `projectsData`) вынесены в IndexedDB; для них есть отдельные TTL и проверка соответствия `projectsDataCompanyId` текущей компании.
- Отдельная логика `invalidateCache`/`onDataCreate|Update|Delete` сбрасывает state и кэш по типу, а для продуктов/услуг сбрасывает оба набора (`lastProducts`, `allProducts`).

## Загрузка данных
- `loadCompanyData` параллелит загрузку критичных и остальных справочников через `Promise.allSettled`, чтобы частичные падения не ломали цепочку.
- Каждая загрузка использует флаги `loadingFlags` + `waitForLoading` для дедупликации запросов.
- `loadClients` и `loadProjects` поддерживают восстановление из кэша и регенерацию DTO при пустом runtime состоянии.
- `loadProductsForSearch` различает последние 10 и полную выборку, умеет работать в simple-режиме и отдаёт DTO.
- `initializeApp`/`loadCurrentCompany`/`setCurrentCompany` последовательно подтягивают пользователя, права, меню и компанию, при смене компании очищают кэш и перезагружают данные.

## Синхронизация и меню
- События `company-updated` и `cache:invalidate` через `eventBus` обновляют текущую компанию, версию логотипа и кэш.
- Меню хранится в localStorage, поддерживает уникальность элементов и фильтрацию по правам; есть дефолтные списки `main`/`available`.

## Замечания и риски
- Вспомогательные функции `logRoundingGetter` и `logCompanyRoundingSettings` не логируют данные; потенциально мёртвый код.
- В `loadClients` присутствует сложная проверка snake/camel кейса, но при несоответствии кэш полностью сбрасывается без попытки миграции.
- `loadCompanyData` помечает `companyData` как загруженное даже при падении всех запросов; единственный fallback — уведомление и консоль.
- В `refreshUserPermissions` при ошибке исключение пробрасывается, но `SET_USER`/`SET_PERMISSIONS` не чистятся; состояние может остаться частично устаревшим.
- В `setCurrentCompany` при ошибке сбрасывается флаг `companyData` в false через `SET_LOADING_FLAG`, но не откатываются возможные частичные изменения (нужно подтверждать, что это ожидаемо).

## Идеи для улучшений
- Добавить единый обработчик ошибок загрузок справочников, возвращающий признак успеха и использующий его в `loadCompanyData` для корректного статуса.
- Упростить обработку клиентских данных: выделить нормализацию формата (snake → camel) в отдельную функцию и применять до записи в кэш, чтобы избежать полного сброса.
- Для `refreshUserPermissions` инициализировать безопасный фоллбек: при ошибке явно чистить permissions/user и инициировать логаут, либо оставить старые данные, но пометить как потенциально устаревшие.
- Рассмотреть отложенное/ленивое обновление menus и кэшей при смене компании вместо полного сброса, если API поддерживает дифф.
- Добавить метрики/логирование для `retryWithExponentialBackoff` (количество попыток, время), чтобы наблюдать устойчивость загрузок.



